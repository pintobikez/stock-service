
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">stock-service/logger.go (100.0%)</option>
				
				<option value="file1">stock-service/main.go (0.0%)</option>
				
				<option value="file2">stock-service/mocks.go (82.8%)</option>
				
				<option value="file3">stock-service/repo.go (0.0%)</option>
				
				<option value="file4">stock-service/reservation.go (88.5%)</option>
				
				<option value="file5">stock-service/router.go (100.0%)</option>
				
				<option value="file6">stock-service/stock.go (76.8%)</option>
				
				<option value="file7">stock-service/stockpubsub.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "net/http"
        "time"
)

func Logger(inner http.Handler, name string) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()

                inner.ServeHTTP(w, r)

                log.Printf(
                        "%s\t%s\t%s\t%s",
                        r.Method,
                        r.RequestURI,
                        name,
                        time.Since(start),
                )
        }</span>)
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "strconv"
        "io/ioutil"
        "net/http"
        "gopkg.in/yaml.v2"
)

var repo *Repository = new(Repository)
var pubsub *FilePublisher = new(FilePublisher)

func loadYaml() string <span class="cov0" title="0">{
        var stringConn = ""
        t := Yconfig{}
    
    data, err := ioutil.ReadFile("config/dev.yml")
    if err != nil </span><span class="cov0" title="0">{
        panic(err)</span>
    }
    <span class="cov0" title="0">err = yaml.Unmarshal([]byte(data), &amp;t)
    if err != nil </span><span class="cov0" title="0">{
        panic(err)</span>
    }

        // [username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;...&amp;paramN=valueN]
        <span class="cov0" title="0">stringConn = t.Mysql.User + ":" + t.Mysql.Pw
        stringConn += "@tcp(" + t.Mysql.Host + ":" + strconv.Itoa(t.Mysql.Port) +")"
        stringConn += "/" + t.Mysql.Schema + "?charset=utf8"

        return stringConn</span>
}

func main() <span class="cov0" title="0">{
        stringConn := loadYaml()

        var routes = Routes{
                Route{
                        "PutStock",
                        "PUT",
                        "/stock/{sku}",
                        PutStock(repo,pubsub),
                },
                Route{
                        "GetStock",
                        "GET",
                        "/stock/{sku}",
                        GetStock(repo),
                },
                Route{
                        "PutReservation",
                        "PUT",
                        "/reservation/{sku}",
                        PutReservation(repo,pubsub),
                },
                Route{
                        "RemoveReservation",
                        "DELETE",
                        "/reservation/{sku}",
                        RemoveReservation(repo,pubsub),
                },
        }

        repo.connectDB(stringConn)
        router := NewRouter(routes)
        log.Fatal(http.ListenAndServe(":8080", router))

        defer repo.disconnectDB()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
)

/* GetStock DataProvider*/
type RepositoryMock struct {
}
func (o *RepositoryMock) connectDB(st string) <span class="cov0" title="0">{
        return
}</span>
func (o *RepositoryMock) disconnectDB() <span class="cov0" title="0">{
        return
}</span>
func (o *RepositoryMock) RepoFindBySkuAndWharehouse(sku string, warehouse string) (*Sku, error) <span class="cov8" title="1">{
        if sku == "SC" &amp;&amp; (warehouse == "A" || warehouse == "C"  || warehouse == "D") </span><span class="cov8" title="1">{
                return &amp;Sku {
                        Sku:"SC",
                        Quantity:1,
                        Warehouse: warehouse,}, nil
        }</span>

        <span class="cov8" title="1">if sku == "SC" &amp;&amp; (warehouse == "B" || warehouse == "D") </span><span class="cov8" title="1">{
                return new(Sku), nil
        }</span>

        <span class="cov8" title="1">return new(Sku), fmt.Errorf("not found")</span>
}
func (o *RepositoryMock) RepoFindSku(sku string) (*SkuResponse, error) <span class="cov8" title="1">{
        if sku == "SC" </span><span class="cov8" title="1">{
                return &amp;SkuResponse{
                        Sku:"SC",
                        Reserved:1,
                        Available:10,
                        Values: []SkuValues{
                                SkuValues{10,"B"},
                                },
                }, nil
        }</span>

        <span class="cov8" title="1">return new(SkuResponse), fmt.Errorf("not found")</span>
}
func (o *RepositoryMock) RepoInsertReservation(re Reservation) error<span class="cov8" title="1">{
        if re.Sku == "SC" &amp;&amp; re.Warehouse == "A" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("not found")</span>
}
func (o *RepositoryMock) RepoDeleteReservation(re Reservation) error <span class="cov8" title="1">{
        if re.Sku == "SC" &amp;&amp; re.Warehouse == "A" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if re.Sku == "SC" &amp;&amp; re.Warehouse == "C" </span><span class="cov8" title="1">{
                return fmt.Errorf("404")
        }</span>
        <span class="cov8" title="1">return fmt.Errorf("not found")</span>
}
func (o *RepositoryMock) RepoUpdateSku(s Sku) (int64, error) <span class="cov8" title="1">{
        if s.Sku == "SC" &amp;&amp; s.Warehouse == "A" </span><span class="cov8" title="1">{
                return 1, nil
        }</span>
        <span class="cov8" title="1">if s.Sku == "SC" &amp;&amp; s.Warehouse == "B" </span><span class="cov0" title="0">{
                return 1, nil
        }</span>
        <span class="cov8" title="1">return 1, fmt.Errorf("not found")</span>
}
func (o *RepositoryMock) RepoInsertSku(s Sku) error <span class="cov8" title="1">{
        if s.Sku == "SC" &amp;&amp; s.Warehouse == "A" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if s.Sku == "SC" &amp;&amp; s.Warehouse == "B" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("not found")</span>
}


//Publisher Mock
type PublisherMock struct {
}
func (p *PublisherMock) Publish(r *SkuResponse) error <span class="cov8" title="1">{
        return nil
}</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "database/sql"
        "fmt"
        _ "github.com/go-sql-driver/mysql"
)

type Repository struct {
        //props
        db *sql.DB
}

func (r *Repository) connectDB(stringConn string) <span class="cov0" title="0">{
        var err error
        r.db, err = sql.Open("mysql", stringConn)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (r *Repository) disconnectDB() <span class="cov0" title="0">{
        r.db.Close()
}</span>

func (r *Repository) RepoFindBySkuAndWharehouse(sku string, warehouse string) (*Sku, error) <span class="cov0" title="0">{
        var quantity int64
        var found bool

        err := r.db.QueryRow("SELECT IF(COUNT(*),'true','false') FROM stock WHERE sku=? AND warehouse=?", sku, warehouse).Scan(&amp;found)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Sku{}, fmt.Errorf(err.Error())
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return &amp;Sku{}, nil
        }</span>

        <span class="cov0" title="0">err = r.db.QueryRow("SELECT quantity FROM stock WHERE sku=? AND warehouse=?", sku, warehouse).Scan(&amp;quantity)
                if err != nil </span><span class="cov0" title="0">{
                return &amp;Sku{}, fmt.Errorf(err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;Sku{Sku: sku, Warehouse: warehouse, Quantity: quantity}, nil</span>
}

func (r *Repository) RepoFindSku(sku string) (*SkuResponse, error) <span class="cov0" title="0">{

        var resp *SkuResponse = new(SkuResponse)

        rows, err := r.db.Query("SELECT sku, warehouse, quantity, reserved, (quantity-reserved) as avail FROM (select s.sku, s.quantity, s.warehouse, (select count(*) from reservation where sku=s.sku and warehouse=s.warehouse) as reserved from stock s where s.sku=?) as t", sku)

        if err != nil </span><span class="cov0" title="0">{
                return resp, fmt.Errorf(err.Error())
        }</span>

        // arr := make([]SkuValues, 0)
        <span class="cov0" title="0">var arr []SkuValues

        for rows.Next() </span><span class="cov0" title="0">{
                var sku string
                var warehouse string
                var quantity int64
                var reserved int64
                var avail int64

                err = rows.Scan(&amp;sku, &amp;warehouse, &amp;quantity, &amp;reserved, &amp;avail)
                if err != nil </span><span class="cov0" title="0">{
                        return resp, fmt.Errorf("Error reading rows: %s", err.Error())
                }</span>

                <span class="cov0" title="0">aux := SkuValues{Quantity: quantity, Warehouse: warehouse}
                arr = append(arr, aux)

                resp.Sku = sku
                resp.Reserved += reserved
                resp.Available += avail
                resp.Values = arr</span>
        }

        <span class="cov0" title="0">return resp, nil</span>
}

func (r *Repository) RepoUpdateSku(s Sku) (int64, error) <span class="cov0" title="0">{

        stmt, err := r.db.Prepare("UPDATE stock SET quantity=? WHERE sku=? AND warehouse=?")

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Error in update stock prepared statement: %s", err.Error())
        }</span>

        <span class="cov0" title="0">res, err := stmt.Exec(s.Quantity, s.Sku, s.Warehouse)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Could not update stock for Sku %s", s.Sku)
        }</span>

        <span class="cov0" title="0">affect, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Could not update stock for Sku %s", s.Sku)
        }</span>

        <span class="cov0" title="0">if affect &lt; 0 </span><span class="cov0" title="0">{
                return affect, fmt.Errorf("Error updating stock for Sku %s", s.Sku)
        }</span>

        <span class="cov0" title="0">defer stmt.Close()

        return affect, nil</span>
}

func (r *Repository) RepoInsertSku(s Sku) error <span class="cov0" title="0">{

        stmt, err := r.db.Prepare("INSERT INTO stock VALUES (?,?,?,now())")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error in insert stock prepared statement: %s", err.Error())
        }</span>

        <span class="cov0" title="0">res, err := stmt.Exec(s.Sku, s.Warehouse, s.Quantity)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not insert stock for Sku %s", s.Sku)
        }</span>
        <span class="cov0" title="0">res.LastInsertId()

        defer stmt.Close()

        return nil</span>
}

func (r *Repository) RepoInsertReservation(re Reservation) error <span class="cov0" title="0">{

        stmt, err := r.db.Prepare("INSERT INTO reservation VALUES (?,?,now())")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error in insert reservation prepared statement: %s", err.Error())
        }</span>

        <span class="cov0" title="0">res, err := stmt.Exec(re.Sku, re.Warehouse)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not insert reservation for Sku %s", re.Sku)
        }</span>
        <span class="cov0" title="0">res.LastInsertId()

        defer stmt.Close()

        return nil</span>
}

func (r *Repository) RepoDeleteReservation(re Reservation) error <span class="cov0" title="0">{

        stmt, err := r.db.Prepare("DELETE FROM reservation WHERE sku=? AND warehouse=? ORDER BY created_at ASC LIMIT 1")

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error in delete reservation prepared statement: %s", err.Error())
        }</span>

        <span class="cov0" title="0">res, err := stmt.Exec(re.Sku, re.Warehouse)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not delete reservation for Sku %s", re.Sku)
        }</span>

        <span class="cov0" title="0">affect, err := res.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Could not delete reservation forSku %s", re.Sku)
        }</span>

        <span class="cov0" title="0">if affect == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("404")
        }</span>

        <span class="cov0" title="0">defer stmt.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "github.com/gorilla/mux"
        "net/http"
)

func ValidateReservation(res Reservation) error <span class="cov8" title="1">{
        if res.Sku == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Sku is empty")
        }</span>
        <span class="cov8" title="1">if res.Warehouse == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Warehouse is empty")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ProcessRequest(w http.ResponseWriter, r Reservation, put bool, rp RepositoryDefinition,p PubSub) (int, error) <span class="cov8" title="1">{
        var skuFound *Sku

        if err := ValidateReservation(r); err != nil </span><span class="cov8" title="1">{
                return http.StatusBadRequest, err
        }</span>

        <span class="cov8" title="1">skuFound, err := rp.RepoFindBySkuAndWharehouse(r.Sku, r.Warehouse)
        if err != nil </span><span class="cov8" title="1">{
                return http.StatusInternalServerError, err
        }</span>

        <span class="cov8" title="1">if skuFound.Sku != "" </span><span class="cov8" title="1">{
                if put </span><span class="cov8" title="1">{
                        if err := rp.RepoInsertReservation(r); err != nil </span><span class="cov8" title="1">{
                                return http.StatusInternalServerError, err
                        }</span>
                }<span class="cov8" title="1"> else {
                        if err := rp.RepoDeleteReservation(r); err != nil </span><span class="cov8" title="1">{
                                if err.Error() == "404" </span><span class="cov8" title="1">{
                                        return http.StatusNotFound, fmt.Errorf("No reservation found for Sku %s and Warehouse %s", r.Sku, r.Warehouse)
                                }</span>
                                <span class="cov8" title="1">return http.StatusInternalServerError, err</span>
                        }
                }
        }<span class="cov8" title="1"> else {
                return http.StatusNotFound, fmt.Errorf("Sku not found")
        }</span>

        <span class="cov8" title="1">skuResponse, err := rp.RepoFindSku(r.Sku)
        if err != nil </span><span class="cov0" title="0">{
                return http.StatusNotFound, fmt.Errorf("Sku %s not found", r.Sku)
        }</span>

        <span class="cov8" title="1">if err := p.Publish(skuResponse); err != nil </span><span class="cov0" title="0">{
                return http.StatusInternalServerError, err
        }</span>

        <span class="cov8" title="1">return http.StatusOK, nil</span>
}

func PutReservation(rp RepositoryDefinition, p PubSub) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(r)
                var res Reservation
                var isset bool
                _ = json.NewDecoder(r.Body).Decode(&amp;res)

                if res.Sku, isset = vars["sku"]; !isset </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">code, err := ProcessRequest(w, res, true, rp, p)
                w.WriteHeader(code)
                if err != nil </span><span class="cov8" title="1">{
                        json.NewEncoder(w).Encode(jsonErr{Code: code, Text: err.Error()})
                }</span>

                <span class="cov8" title="1">return</span>
        }
}

func RemoveReservation(rp RepositoryDefinition, p PubSub) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                vars := mux.Vars(r)
                var res Reservation
                var isset bool
                _ = json.NewDecoder(r.Body).Decode(&amp;res)

                if res.Sku, isset = vars["sku"]; !isset </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if code, err := ProcessRequest(w, res, false, rp, p); err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(code)
                        json.NewEncoder(w).Encode(jsonErr{Code: code, Text: err.Error()})
                }</span><span class="cov8" title="1"> else {
                        w.WriteHeader(code)
                }</span>

                <span class="cov8" title="1">return</span>
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "github.com/gorilla/mux"
        "net/http"
)

func NewRouter(routes Routes) *mux.Router <span class="cov8" title="1">{

        router := mux.NewRouter().StrictSlash(true)
        for _, route := range routes </span><span class="cov8" title="1">{
                var handler http.Handler

                handler = route.HandlerFunc
                handler = Logger(handler, route.Name)

                router.
                        Methods(route.Method).
                        Path(route.Pattern).
                        Name(route.Name).
                        Handler(handler)
        }</span>

        <span class="cov8" title="1">return router</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "github.com/gorilla/mux"
        "net/http"
)

func ValidateSku(s Sku) error <span class="cov8" title="1">{
        if s.Sku == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Sku is empty")
        }</span>
        <span class="cov8" title="1">if s.Warehouse == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("Warehouse is empty")
        }</span>
        <span class="cov8" title="1">if s.Quantity &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Quantity is negative")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func GetStock(rp RepositoryDefinition) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json; charset=UTF-8")

                vars := mux.Vars(r)
                var skuResponse *SkuResponse
                var err error

                skuValue, isset := vars["sku"]
                if !isset </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">skuResponse, err = rp.RepoFindSku(skuValue)
                if err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNotFound)
                        if err2 := json.NewEncoder(w).Encode(jsonErr{Code: http.StatusNotFound, Text: err.Error()}); err2 != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">if err = json.NewEncoder(w).Encode(skuResponse); err != nil </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov8" title="1">return</span>
        }
}

func PutStock(rp RepositoryDefinition, p PubSub) func(http.ResponseWriter, *http.Request) <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json; charset=UTF-8")

                var err error
                var isset bool
                var af int64 = 1

                vars := mux.Vars(r)
                var s Sku
                _ = json.NewDecoder(r.Body).Decode(&amp;s)

                s.Sku, isset = vars["sku"]
                if !isset </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusBadRequest)
                        return
                }</span>

                <span class="cov8" title="1">if err := ValidateSku(s); err != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusBadRequest)
                        json.NewEncoder(w).Encode(jsonErr{Code: http.StatusBadRequest, Text: err.Error()})
                        return
                }</span>

                <span class="cov8" title="1">f, erre := rp.RepoFindBySkuAndWharehouse(s.Sku, s.Warehouse)
                if erre != nil </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusInternalServerError)
                        json.NewEncoder(w).Encode(jsonErr{Code: http.StatusInternalServerError, Text: erre.Error()})
                        return
                }</span>

                <span class="cov8" title="1">if f.Sku != "" </span><span class="cov8" title="1">{
                        af, err = rp.RepoUpdateSku(s)
                        if err != nil </span><span class="cov8" title="1">{
                                w.WriteHeader(http.StatusInternalServerError)
                                json.NewEncoder(w).Encode(jsonErr{Code: http.StatusInternalServerError, Text: err.Error()})
                                return
                        }</span>
                }<span class="cov8" title="1"> else {
                        if err = rp.RepoInsertSku(s); err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                json.NewEncoder(w).Encode(jsonErr{Code: http.StatusInternalServerError, Text: err.Error()})
                                return
                        }</span>
                }

                <span class="cov8" title="1">json.NewEncoder(w).Encode(s)
                if af &gt; 0 </span><span class="cov8" title="1">{ //publish message
                        skuResponse, err := rp.RepoFindSku(s.Sku)
                        if err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusNotFound)
                                json.NewEncoder(w).Encode(jsonErr{Code: http.StatusNotFound, Text: "Sku "+s.Sku+" not found"})
                                return
                        }</span>

                        <span class="cov8" title="1">if err := p.Publish(skuResponse); err != nil </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusInternalServerError)
                                json.NewEncoder(w).Encode(jsonErr{Code: http.StatusInternalServerError, Text: err.Error()})
                                return
                        }</span>
                }
                <span class="cov8" title="1">return</span>
        }
}</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "encoding/json"
        "os"
)

type FilePublisher struct {
}

func (p *FilePublisher) Publish(s *SkuResponse) error <span class="cov0" title="0">{
        jsonOutpout, _ := json.Marshal(s)

        f, err := os.OpenFile("queue.json", os.O_APPEND|os.O_WRONLY, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">defer f.Close()

        if _, err = f.Write(jsonOutpout); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">f.WriteString("\n")

        return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
